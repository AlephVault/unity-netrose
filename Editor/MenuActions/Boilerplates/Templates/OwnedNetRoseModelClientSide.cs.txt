// Using UnityEngine;
using AlephVault.Unity.Meetgard.Types;
using AlephVault.Unity.Binary.Wrappers;
using GameMeanMachine.Unity.NetRose.Authoring.Behaviours.Client;
using GameMeanMachine.Unity.NetRose.Types.Models;

namespace Client.Authoring.Behaviours.NetworkObjects
{
    public class #SCRIPTNAME# : OwnedNetRoseModelClientSide<#SPAWNDATA_TYPE#, #REFRESHDATA_TYPE#>
    {
        /// <summary>
        ///   Tracks the current instance.
        /// </summary>
        public static #SCRIPTNAME# Instance = null { get; private set; }
        
        // THIS BEHAVIOUR IS MEANT TO BE ATTACHED TO MAP OBJECTS
        // THAT ARE MEANT TO BE SYNCHRONIZED THROUGH THE NETWORK.
        // THIS MEANS: OBJECTS THAT SHOULD RECEIVE REAL-TIME UPDATES
        // FROM THE CONNECTED SERVER.
        
        // As an example, you might want this principal object to be
        // tracked by a camera of your choice.
        // private static Camera camera = Camera.main;

        protected override void InflateOwnedFrom(#SPAWNDATA_TYPE# fullData)
        {
            // Implement this method to visually update this object
            // based on the full spawn data received through the
            // network update.
        }
        
        protected override void UpdateFrom(#REFRESHDATA_TYPE# refreshData)
        {
            // Implement this method to visually update this object
            // based on the refresh data received through the network
            // update. Depending on how the game is designed, it can
            // represent a full refresh data object or a partial one,
            // so some aspects are only meant to be refreshed.
        }
        
        // Following the example, you might like the camera to follow
        // this object.
        /**
        private void Update()
        {
            if (isOwned && camera) camera.transform.position = new Vector3(
                transform.position.x, transform.position.y, -10
            );
        }
        */
    }
}
